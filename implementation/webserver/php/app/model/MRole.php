<?php

/**
 * @brief Model for role object.
 */
class MRole extends MObjectModel {
    /**
     * @const urlPrefix
     * Used for generating url for this model.
     */
    const urlPrefix = 'role';
    /**
     * @var $name
     * Name of role loaded from database.
     */
    public $name;
    /**
     * @var $canEditColls
     * Boolean flag determining if this role can edit collections. Loaded from database.
     */
    public $canEditColls;
    /**
     * @var $canEditUsers
     * Boolean flag determining if this role can edit users. Loaded from database.
     */
    public $canEditUsers;
    /**
     * @var $canEditDevices
     * Boolean flag determining if this role can edit devices. Loaded from database.
     */
    public $canEditDevices;
    /**
     * @var $canEditGateways
     * Boolean flag determining if this role can edit gateways. Loaded from database.
     */
    public $canEditGateways;
    /**
     * @var $canEditAll
     * Boolean flag determining if this role can edit all and has a complete admin access to this portal. Loaded from database.
     */
    public $canEditAll;
    /**
     * @var $canListColls
     * Boolean flag determining if this role can list collections. Loaded from database.
     */
    public $canListColls;
    /**
     * @var $canListUsers
     * Boolean flag determining if this role can list users. Loaded from database.
     */
    public $canListUsers;
    /**
     * @var $canListDevices
     * Boolean flag determining if this role can list devices. Loaded from database.
     */
    public $canListDevices;
    /**
     * @var $canListGateways
     * Boolean flag determining if this role can list gateways. Loaded from database.
     */
    public $canListGateways;
    /**
     * @var $tmpId
     * Id that is used during storing phase, if storing is successful, $id is set to $tmpId.
     */
    private $tmpId;

    /**
     * Constructs model using data from database.
     * @param $id Id of role in database.
     */
    public function __construct($id = 0) {
        parent::__construct();
        if($id) {
            $sqls=DB::query("SELECT * FROM roles WHERE id=$id");
            $o=$sqls->fetchObject();
            if ($o) {
                $this->id = $o->id;
                $this->name = $o->name;
                $this->canEditColls = $o->can_edit_colls;
                $this->canEditUsers = $o->can_edit_users;
                $this->canEditDevices = $o->can_edit_devices;
                $this->canEditGateways = $o->can_edit_gateways;
                $this->canEditAll = $o->can_edit_all;
                $this->canListColls = $o->can_list_colls;
                $this->canListUsers = $o->can_list_users;
                $this->canListDevices = $o->can_list_devices;
                $this->canListGateways = $o->can_list_gateways;
            }
        }
    }

    /**
     * @brief Tries to store data to database.
     * @param null $arg Universal argument, not used here.
     * @return bool Storing was successful.
     */
    public function store(int $arg = 0) : bool {
        if (!parent::store()) return false; // TODO: Change the autogenerated stub
        $sql = $this->id ? "UPDATE" : "INSERT INTO";
        $sql.=  " roles SET name=:name, can_edit_colls=:can_edit_colls, can_edit_users=:can_edit_users,".
                " can_edit_gateways=:can_edit_gateways, can_edit_devices=:can_edit_devices,".
                " can_edit_all=:can_edit_all, can_list_colls=:can_list_colls,".
                " can_list_users=:can_list_users, can_list_devices=:can_list_devices,".
                " can_list_gateways=:can_list_gateways";
        if ($this->id) $sql.=" WHERE id=$this->id";
        $sqls=DB::prepare($sql);
        $res = true;
        try {
            $res = $sqls->execute(["name" => $this->name, "can_edit_colls" => $this->canEditColls,
                "can_edit_users" => $this->canEditUsers, "can_edit_devices" => $this->canEditDevices,
                "can_edit_gateways" => $this->canEditGateways, "can_edit_all" => $this->canEditAll,
                "can_list_colls" => $this->canListColls, "can_list_users" => $this->canListUsers,
                "can_list_devices" => $this->canListDevices, "can_list_gateways" => $this->canListGateways]);
        } catch (PDOException) {
            $res = false;
        }
        if (!$res) {
            error_log(get_called_class().": SQL Error.");
            return false;
        }
        if (!$this->id) $this->tmpId = DB::lastInsertId();
        return true;
    }

    /**
     * @brief Used when storing in database was successful. Commits all changes to model and database.
     * @return void
     */
    public function storeCommit() : void {
        parent::storeCommit();
        if (!$this->id) $this->id = $this->tmpId;
    }

    /**
     * @brief Deletes corresponding record from database.
     * @return bool Deletion was successful.
     */
    public function delete($arg = NULL) : bool {
        if (!$this->id) return TRUE;
        $sql = "DELETE FROM roles WHERE id=$this->id";
        if (FALSE===DB::exec($sql)) return FALSE;
        if (FALSE===parent::delete()) return FALSE;
        $this->tmpId = NULL;
        return TRUE;
    }

    /**
     * Starts saving process to database.
     * Called when button in edit form using this model is pressed. Adds notification to user about result.
     * @return void
     */
    public function clickedSubmit() {
        if ($this->persist()) VPageHollow::addNotification(new VNotification(VNotification::NT_Success, "Role was saved."));
        else VPageHollow::addNotification(new VNotification(VNotification::NT_Error, "Role could not have been saved!"));
    }

    /**
     * Starts deleting process in database.
     * If not successful, reverts changes made. Adds notification to user about result.
     * @return bool
     */
    public function unpersist() : bool {
        $ret = parent::unpersist();
        if ($ret) VPageHollow::addNotification(new VNotification(VNotification::NT_Success, "Role was deleted."));
        else VPageHollow::addNotification(new VNotification(VNotification::NT_Error, "Role could not have been saved!"));
        return $ret;
    }
}